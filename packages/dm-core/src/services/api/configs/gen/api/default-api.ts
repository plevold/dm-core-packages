/* tslint:disable */
/* eslint-disable */
/**
 * Data Modelling Storage Service
 * API for basic data modelling interaction
 *
 * The version of the OpenAPI document: 1.2.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ACL } from '../models';
// @ts-ignore
import { AccessLevel } from '../models';
// @ts-ignore
import { DataSourceInformation } from '../models';
// @ts-ignore
import { DataSourceRequest } from '../models';
// @ts-ignore
import { Entity } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { GetBlueprintResponse } from '../models';
// @ts-ignore
import { Lookup } from '../models';
// @ts-ignore
import { PATData } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (pathAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathAddress' is not null or undefined
            assertParamExists('_export', 'pathAddress', pathAddress)
            const localVarPath = `/api/export/{path_address}`
                .replace(`{${"path_address"}}`, encodeURIComponent(String(pathAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the attribute from a address.
         * @summary Get Attribute
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeGet: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('attributeGet', 'address', address)
            const localVarPath = `/api/attribute/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById: async (dataSourceId: string, blobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobGetById', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobGetById', 'blobId', blobId)
            const localVarPath = `/api/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload: async (dataSourceId: string, blobId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobUpload', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobUpload', 'blobId', blobId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('blobUpload', 'file', file)
            const localVarPath = `/api/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet: async (typeRef: string, context?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeRef' is not null or undefined
            assertParamExists('blueprintGet', 'typeRef', typeRef)
            const localVarPath = `/api/blueprint/{type_ref}`
                .replace(`{${"type_ref"}}`, encodeURIComponent(String(typeRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve address of a blueprint to its type path.  - **address**: <protocol>://<data_source</$<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('blueprintResolve', 'address', address)
            const localVarPath = `/api/resolve-path/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application - **recipe_package**: List with one or more paths to package(s) that contain recipe links. (Example: \'system/SIMOS/recipe_links\')
         * @summary Create Lookup
         * @param {string} application 
         * @param {Array<string>} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLookup: async (application: string, recipePackage: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createLookup', 'application', application)
            // verify required parameter 'recipePackage' is not null or undefined
            assertParamExists('createLookup', 'recipePackage', recipePackage)
            const localVarPath = `/api/application/{application}`
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (recipePackage) {
                localVarQueryParameter['recipe_package'] = recipePackage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceGet', 'dataSourceId', dataSourceId)
            const localVarPath = `/api/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave: async (dataSourceId: string, dataSourceRequest: DataSourceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceId', dataSourceId)
            // verify required parameter 'dataSourceRequest' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceRequest', dataSourceRequest)
            const localVarPath = `/api/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a document to a package (or a data source) using an address.  - **address**:   - Reference to data source: PROTOCOL://DATA SOURCE   - Reference to package by id: PROTOCOL://DATA SOURCE/$ID   - Reference to package by path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE   The PROTOCOL is optional, and the default is dmss.  This endpoint can be used for: - Adding elements to a list attribute in an entity. - Adding a new document to a package / data source - Adding an object to an entity (for example filling in an optional, complex attribute)
         * @summary Add Document
         * @param {string} address 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAdd: async (address: string, document: string, updateUncontained?: boolean, files?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('documentAdd', 'address', address)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('documentAdd', 'document', document)
            const localVarPath = `/api/documents/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddSimple: async (dataSourceId: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentAddSimple', 'dataSourceId', dataSourceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('documentAddSimple', 'body', body)
            const localVarPath = `/api/documents-add-raw/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document as JSON string.  - **address**: An address to a package or a data source   - By id: PROTOCOL://DATA SOURCE/$ID.Attribute   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY.Attribute   - By query: PROTOCOL://DATA SOURCE/$ID.list(key=value)  The PROTOCOL is optional, and the default is dmss.  - **depth**: Maximum depth for resolving nested documents.
         * @summary Get
         * @param {string} address 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGet: async (address: string, depth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('documentGet', 'address', address)
            const localVarPath = `/api/documents/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a document from DMSS.
         * @summary Remove
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemove: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('documentRemove', 'address', address)
            const localVarPath = `/api/documents/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update document - **id_address**: <protocol>://<data_source>/$<document_uuid> (can also include an optional .<attribute> after <document_uuid>)
         * @summary Update
         * @param {string} idAddress 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate: async (idAddress: string, data: string, updateUncontained?: boolean, files?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idAddress' is not null or undefined
            assertParamExists('documentUpdate', 'idAddress', idAddress)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentUpdate', 'data', data)
            const localVarPath = `/api/documents/{id_address}`
                .replace(`{${"id_address"}}`, encodeURIComponent(String(idAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export Meta
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMeta: async (pathAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathAddress' is not null or undefined
            assertParamExists('exportMeta', 'pathAddress', pathAddress)
            const localVarPath = `/api/export/meta/{path_address}`
                .replace(`{${"path_address"}}`, encodeURIComponent(String(pathAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new binary file and create a file entity with the binary data as content.  **file_id** The data source ID to be used for the file entity that will be created.
         * @summary Upload File
         * @param {string} dataSourceId 
         * @param {string} data 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUpload: async (dataSourceId: string, data: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('fileUpload', 'dataSourceId', dataSourceId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('fileUpload', 'data', data)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('fileUpload', 'file', file)
            const localVarPath = `/api/files/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl: async (dataSourceId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('getAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getAcl', 'documentId', documentId)
            const localVarPath = `/api/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiHealthcheckGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLookup: async (application: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getLookup', 'application', application)
            const localVarPath = `/api/application/{application}`
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a default entity of specified type. This entity is not stored in the database.  Rules for instantiation: - all required attributes, as defined in the blueprint, are included.   If the required attribute has a default value, that value will be used.   If not, an \'empty\' value will be used. For example empty string,   an empty list, the number 0, etc. - optional attributes are not included (also true if optional attribute has a default value)
         * @summary Instantiate
         * @param {Entity} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instantiateEntity: async (entity: Entity, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('instantiateEntity', 'entity', entity)
            const localVarPath = `/api/entity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get meta information from data source id.
         * @summary Get Meta By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaById: async (dataSourceId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('metaById', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('metaById', 'documentId', documentId)
            const localVarPath = `/api/meta/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('referenceDelete', 'address', address)
            const localVarPath = `/api/reference/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (body: object, dataSources?: Array<string>, sortByAttribute?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('search', 'body', body)
            const localVarPath = `/api/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (dataSources) {
                localVarQueryParameter['data_sources'] = dataSources;
            }

            if (sortByAttribute !== undefined) {
                localVarQueryParameter['sort_by_attribute'] = sortByAttribute;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl: async (dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('setAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('setAcl', 'documentId', documentId)
            // verify required parameter 'aCL' is not null or undefined
            assertParamExists('setAcl', 'aCL', aCL)
            const localVarPath = `/api/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (recursively !== undefined) {
                localVarQueryParameter['recursively'] = recursively;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCL, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (scope?: AccessLevel, timeToLive?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (timeToLive !== undefined) {
                localVarQueryParameter['time_to_live'] = timeToLive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokenDelete', 'tokenId', tokenId)
            const localVarPath = `/api/token/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an entity. Will return detailed error messages and status code 422 if the entity is invalid.  \"as_type\": Optional. Validate the root entity against this type instead of the one defined in the entity.
         * @summary Validate
         * @param {Entity} entity 
         * @param {string} [asType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity: async (entity: Entity, asType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('validateEntity', 'entity', entity)
            const localVarPath = `/api/entity/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (asType !== undefined) {
                localVarQueryParameter['as_type'] = asType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an existing entity in dmss. Will return detailed error messages and status code 422 if an entity is invalid.
         * @summary Validate Existing
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExistingEntity: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateExistingEntity', 'address', address)
            const localVarPath = `/api/entity/validate-existing-entity/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(pathAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(pathAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the attribute from a address.
         * @summary Get Attribute
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attributeGet(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attributeGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobGetById(dataSourceId: string, blobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobGetById(dataSourceId, blobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobUpload(dataSourceId: string, blobId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobUpload(dataSourceId, blobId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintGet(typeRef: string, context?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlueprintResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintGet(typeRef, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolve address of a blueprint to its type path.  - **address**: <protocol>://<data_source</$<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintResolve(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintResolve(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application - **recipe_package**: List with one or more paths to package(s) that contain recipe links. (Example: \'system/SIMOS/recipe_links\')
         * @summary Create Lookup
         * @param {string} application 
         * @param {Array<string>} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLookup(application: string, recipePackage: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLookup(application, recipePackage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGet(dataSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGet(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSourceInformation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceSave(dataSourceId, dataSourceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a document to a package (or a data source) using an address.  - **address**:   - Reference to data source: PROTOCOL://DATA SOURCE   - Reference to package by id: PROTOCOL://DATA SOURCE/$ID   - Reference to package by path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE   The PROTOCOL is optional, and the default is dmss.  This endpoint can be used for: - Adding elements to a list attribute in an entity. - Adding a new document to a package / data source - Adding an object to an entity (for example filling in an optional, complex attribute)
         * @summary Add Document
         * @param {string} address 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAdd(address: string, document: string, updateUncontained?: boolean, files?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAdd(address, document, updateUncontained, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAddSimple(dataSourceId: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAddSimple(dataSourceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get document as JSON string.  - **address**: An address to a package or a data source   - By id: PROTOCOL://DATA SOURCE/$ID.Attribute   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY.Attribute   - By query: PROTOCOL://DATA SOURCE/$ID.list(key=value)  The PROTOCOL is optional, and the default is dmss.  - **depth**: Maximum depth for resolving nested documents.
         * @summary Get
         * @param {string} address 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentGet(address: string, depth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentGet(address, depth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a document from DMSS.
         * @summary Remove
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentRemove(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentRemove(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update document - **id_address**: <protocol>://<data_source>/$<document_uuid> (can also include an optional .<attribute> after <document_uuid>)
         * @summary Update
         * @param {string} idAddress 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentUpdate(idAddress: string, data: string, updateUncontained?: boolean, files?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentUpdate(idAddress, data, updateUncontained, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export Meta
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportMeta(pathAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportMeta(pathAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a new binary file and create a file entity with the binary data as content.  **file_id** The data source ID to be used for the file entity that will be created.
         * @summary Upload File
         * @param {string} dataSourceId 
         * @param {string} data 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileUpload(dataSourceId: string, data: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileUpload(dataSourceId, data, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcl(dataSourceId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcl(dataSourceId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiHealthcheckGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiHealthcheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLookup(application: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLookup(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a default entity of specified type. This entity is not stored in the database.  Rules for instantiation: - all required attributes, as defined in the blueprint, are included.   If the required attribute has a default value, that value will be used.   If not, an \'empty\' value will be used. For example empty string,   an empty list, the number 0, etc. - optional attributes are not included (also true if optional attribute has a default value)
         * @summary Instantiate
         * @param {Entity} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instantiateEntity(entity: Entity, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instantiateEntity(entity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get meta information from data source id.
         * @summary Get Meta By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaById(dataSourceId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaById(dataSourceId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referenceDelete(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referenceDelete(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(body, dataSources, sortByAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAcl(dataSourceId, documentId, aCL, recursively, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(scope, timeToLive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenListAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PATData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenListAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate an entity. Will return detailed error messages and status code 422 if the entity is invalid.  \"as_type\": Optional. Validate the root entity against this type instead of the one defined in the entity.
         * @summary Validate
         * @param {Entity} entity 
         * @param {string} [asType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateEntity(entity: Entity, asType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateEntity(entity, asType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate an existing entity in dmss. Will return detailed error messages and status code 422 if an entity is invalid.
         * @summary Validate Existing
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateExistingEntity(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateExistingEntity(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(pathAddress: string, options?: any): AxiosPromise<void> {
            return localVarFp._export(pathAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the attribute from a address.
         * @summary Get Attribute
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attributeGet(address: string, options?: any): AxiosPromise<object> {
            return localVarFp.attributeGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById(dataSourceId: string, blobId: string, options?: any): AxiosPromise<File> {
            return localVarFp.blobGetById(dataSourceId, blobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload(dataSourceId: string, blobId: string, file: File, options?: any): AxiosPromise<string> {
            return localVarFp.blobUpload(dataSourceId, blobId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet(typeRef: string, context?: string, options?: any): AxiosPromise<GetBlueprintResponse> {
            return localVarFp.blueprintGet(typeRef, context, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve address of a blueprint to its type path.  - **address**: <protocol>://<data_source</$<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve(address: string, options?: any): AxiosPromise<string> {
            return localVarFp.blueprintResolve(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application - **recipe_package**: List with one or more paths to package(s) that contain recipe links. (Example: \'system/SIMOS/recipe_links\')
         * @summary Create Lookup
         * @param {string} application 
         * @param {Array<string>} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLookup(application: string, recipePackage: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.createLookup(application, recipePackage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet(dataSourceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.dataSourceGet(dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll(options?: any): AxiosPromise<Array<DataSourceInformation>> {
            return localVarFp.dataSourceGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: any): AxiosPromise<string> {
            return localVarFp.dataSourceSave(dataSourceId, dataSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a document to a package (or a data source) using an address.  - **address**:   - Reference to data source: PROTOCOL://DATA SOURCE   - Reference to package by id: PROTOCOL://DATA SOURCE/$ID   - Reference to package by path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE   The PROTOCOL is optional, and the default is dmss.  This endpoint can be used for: - Adding elements to a list attribute in an entity. - Adding a new document to a package / data source - Adding an object to an entity (for example filling in an optional, complex attribute)
         * @summary Add Document
         * @param {string} address 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAdd(address: string, document: string, updateUncontained?: boolean, files?: Array<File>, options?: any): AxiosPromise<object> {
            return localVarFp.documentAdd(address, document, updateUncontained, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddSimple(dataSourceId: string, body: object, options?: any): AxiosPromise<string> {
            return localVarFp.documentAddSimple(dataSourceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document as JSON string.  - **address**: An address to a package or a data source   - By id: PROTOCOL://DATA SOURCE/$ID.Attribute   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY.Attribute   - By query: PROTOCOL://DATA SOURCE/$ID.list(key=value)  The PROTOCOL is optional, and the default is dmss.  - **depth**: Maximum depth for resolving nested documents.
         * @summary Get
         * @param {string} address 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGet(address: string, depth?: number, options?: any): AxiosPromise<object> {
            return localVarFp.documentGet(address, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a document from DMSS.
         * @summary Remove
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemove(address: string, options?: any): AxiosPromise<any> {
            return localVarFp.documentRemove(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Update document - **id_address**: <protocol>://<data_source>/$<document_uuid> (can also include an optional .<attribute> after <document_uuid>)
         * @summary Update
         * @param {string} idAddress 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate(idAddress: string, data: string, updateUncontained?: boolean, files?: Array<File>, options?: any): AxiosPromise<any> {
            return localVarFp.documentUpdate(idAddress, data, updateUncontained, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
         * @summary Export Meta
         * @param {string} pathAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMeta(pathAddress: string, options?: any): AxiosPromise<any> {
            return localVarFp.exportMeta(pathAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new binary file and create a file entity with the binary data as content.  **file_id** The data source ID to be used for the file entity that will be created.
         * @summary Upload File
         * @param {string} dataSourceId 
         * @param {string} data 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUpload(dataSourceId: string, data: string, file: File, options?: any): AxiosPromise<object> {
            return localVarFp.fileUpload(dataSourceId, data, file, options).then((request) => request(axios, basePath));
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl(dataSourceId: string, documentId: string, options?: any): AxiosPromise<ACL> {
            return localVarFp.getAcl(dataSourceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiHealthcheckGet(options?: any): AxiosPromise<string> {
            return localVarFp.getApiHealthcheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLookup(application: string, options?: any): AxiosPromise<Lookup> {
            return localVarFp.getLookup(application, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a default entity of specified type. This entity is not stored in the database.  Rules for instantiation: - all required attributes, as defined in the blueprint, are included.   If the required attribute has a default value, that value will be used.   If not, an \'empty\' value will be used. For example empty string,   an empty list, the number 0, etc. - optional attributes are not included (also true if optional attribute has a default value)
         * @summary Instantiate
         * @param {Entity} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instantiateEntity(entity: Entity, options?: any): AxiosPromise<Entity> {
            return localVarFp.instantiateEntity(entity, options).then((request) => request(axios, basePath));
        },
        /**
         * Get meta information from data source id.
         * @summary Get Meta By Id
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaById(dataSourceId: string, documentId: string, options?: any): AxiosPromise<object> {
            return localVarFp.metaById(dataSourceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete(address: string, options?: any): AxiosPromise<object> {
            return localVarFp.referenceDelete(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: any): AxiosPromise<object> {
            return localVarFp.search(body, dataSources, sortByAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.setAcl(dataSourceId, documentId, aCL, recursively, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: any): AxiosPromise<string> {
            return localVarFp.tokenCreate(scope, timeToLive, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(tokenId: string, options?: any): AxiosPromise<string> {
            return localVarFp.tokenDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll(options?: any): AxiosPromise<Array<PATData>> {
            return localVarFp.tokenListAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an entity. Will return detailed error messages and status code 422 if the entity is invalid.  \"as_type\": Optional. Validate the root entity against this type instead of the one defined in the entity.
         * @summary Validate
         * @param {Entity} entity 
         * @param {string} [asType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEntity(entity: Entity, asType?: string, options?: any): AxiosPromise<any> {
            return localVarFp.validateEntity(entity, asType, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an existing entity in dmss. Will return detailed error messages and status code 422 if an entity is invalid.
         * @summary Validate Existing
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExistingEntity(address: string, options?: any): AxiosPromise<any> {
            return localVarFp.validateExistingEntity(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<any> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _export operation in DefaultApi.
 * @export
 * @interface DefaultApiExportRequest
 */
export interface DefaultApiExportRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExport
     */
    readonly pathAddress: string
}

/**
 * Request parameters for attributeGet operation in DefaultApi.
 * @export
 * @interface DefaultApiAttributeGetRequest
 */
export interface DefaultApiAttributeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiAttributeGet
     */
    readonly address: string
}

/**
 * Request parameters for blobGetById operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobGetByIdRequest
 */
export interface DefaultApiBlobGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly blobId: string
}

/**
 * Request parameters for blobUpload operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobUploadRequest
 */
export interface DefaultApiBlobUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly blobId: string

    /**
     * 
     * @type {File}
     * @memberof DefaultApiBlobUpload
     */
    readonly file: File
}

/**
 * Request parameters for blueprintGet operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintGetRequest
 */
export interface DefaultApiBlueprintGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintGet
     */
    readonly typeRef: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintGet
     */
    readonly context?: string
}

/**
 * Request parameters for blueprintResolve operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintResolveRequest
 */
export interface DefaultApiBlueprintResolveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintResolve
     */
    readonly address: string
}

/**
 * Request parameters for createLookup operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateLookupRequest
 */
export interface DefaultApiCreateLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateLookup
     */
    readonly application: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiCreateLookup
     */
    readonly recipePackage: Array<string>
}

/**
 * Request parameters for dataSourceGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceGetRequest
 */
export interface DefaultApiDataSourceGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceGet
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for dataSourceSave operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceSaveRequest
 */
export interface DefaultApiDataSourceSaveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {DataSourceRequest}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceRequest: DataSourceRequest
}

/**
 * Request parameters for documentAdd operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentAddRequest
 */
export interface DefaultApiDocumentAddRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAdd
     */
    readonly address: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAdd
     */
    readonly document: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentAdd
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {Array<File>}
     * @memberof DefaultApiDocumentAdd
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for documentAddSimple operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentAddSimpleRequest
 */
export interface DefaultApiDocumentAddSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAddSimple
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {object}
     * @memberof DefaultApiDocumentAddSimple
     */
    readonly body: object
}

/**
 * Request parameters for documentGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentGetRequest
 */
export interface DefaultApiDocumentGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGet
     */
    readonly address: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiDocumentGet
     */
    readonly depth?: number
}

/**
 * Request parameters for documentRemove operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentRemoveRequest
 */
export interface DefaultApiDocumentRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentRemove
     */
    readonly address: string
}

/**
 * Request parameters for documentUpdate operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentUpdateRequest
 */
export interface DefaultApiDocumentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly idAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly data: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {Array<File>}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for exportMeta operation in DefaultApi.
 * @export
 * @interface DefaultApiExportMetaRequest
 */
export interface DefaultApiExportMetaRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExportMeta
     */
    readonly pathAddress: string
}

/**
 * Request parameters for fileUpload operation in DefaultApi.
 * @export
 * @interface DefaultApiFileUploadRequest
 */
export interface DefaultApiFileUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiFileUpload
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiFileUpload
     */
    readonly data: string

    /**
     * 
     * @type {File}
     * @memberof DefaultApiFileUpload
     */
    readonly file: File
}

/**
 * Request parameters for getAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAclRequest
 */
export interface DefaultApiGetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly documentId: string
}

/**
 * Request parameters for getLookup operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLookupRequest
 */
export interface DefaultApiGetLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetLookup
     */
    readonly application: string
}

/**
 * Request parameters for instantiateEntity operation in DefaultApi.
 * @export
 * @interface DefaultApiInstantiateEntityRequest
 */
export interface DefaultApiInstantiateEntityRequest {
    /**
     * 
     * @type {Entity}
     * @memberof DefaultApiInstantiateEntity
     */
    readonly entity: Entity
}

/**
 * Request parameters for metaById operation in DefaultApi.
 * @export
 * @interface DefaultApiMetaByIdRequest
 */
export interface DefaultApiMetaByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiMetaById
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiMetaById
     */
    readonly documentId: string
}

/**
 * Request parameters for referenceDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiReferenceDeleteRequest
 */
export interface DefaultApiReferenceDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceDelete
     */
    readonly address: string
}

/**
 * Request parameters for search operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchRequest
 */
export interface DefaultApiSearchRequest {
    /**
     * 
     * @type {object}
     * @memberof DefaultApiSearch
     */
    readonly body: object

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSearch
     */
    readonly dataSources?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSearch
     */
    readonly sortByAttribute?: string
}

/**
 * Request parameters for setAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiSetAclRequest
 */
export interface DefaultApiSetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly documentId: string

    /**
     * 
     * @type {ACL}
     * @memberof DefaultApiSetAcl
     */
    readonly aCL: ACL

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiSetAcl
     */
    readonly recursively?: boolean
}

/**
 * Request parameters for tokenCreate operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenCreateRequest
 */
export interface DefaultApiTokenCreateRequest {
    /**
     * 
     * @type {AccessLevel}
     * @memberof DefaultApiTokenCreate
     */
    readonly scope?: AccessLevel

    /**
     * 
     * @type {number}
     * @memberof DefaultApiTokenCreate
     */
    readonly timeToLive?: number
}

/**
 * Request parameters for tokenDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenDeleteRequest
 */
export interface DefaultApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTokenDelete
     */
    readonly tokenId: string
}

/**
 * Request parameters for validateEntity operation in DefaultApi.
 * @export
 * @interface DefaultApiValidateEntityRequest
 */
export interface DefaultApiValidateEntityRequest {
    /**
     * 
     * @type {Entity}
     * @memberof DefaultApiValidateEntity
     */
    readonly entity: Entity

    /**
     * 
     * @type {string}
     * @memberof DefaultApiValidateEntity
     */
    readonly asType?: string
}

/**
 * Request parameters for validateExistingEntity operation in DefaultApi.
 * @export
 * @interface DefaultApiValidateExistingEntityRequest
 */
export interface DefaultApiValidateExistingEntityRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiValidateExistingEntity
     */
    readonly address: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Download a zip-folder with one or more documents as json file(s).  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
     * @summary Export
     * @param {DefaultApiExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _export(requestParameters: DefaultApiExportRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)._export(requestParameters.pathAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the attribute from a address.
     * @summary Get Attribute
     * @param {DefaultApiAttributeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public attributeGet(requestParameters: DefaultApiAttributeGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).attributeGet(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get blob from id. A blob (binary large object) can be anything from video to text file.
     * @summary Get By Id
     * @param {DefaultApiBlobGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobGetById(requestParameters: DefaultApiBlobGetByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blobGetById(requestParameters.dataSourceId, requestParameters.blobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a new blob. A blob (binary large object) can be anything from video to text file.
     * @summary Upload
     * @param {DefaultApiBlobUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobUpload(requestParameters: DefaultApiBlobUploadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blobUpload(requestParameters.dataSourceId, requestParameters.blobId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
     * @summary Get Blueprint
     * @param {DefaultApiBlueprintGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintGet(requestParameters: DefaultApiBlueprintGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blueprintGet(requestParameters.typeRef, requestParameters.context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve address of a blueprint to its type path.  - **address**: <protocol>://<data_source</$<blueprint_uuid>
     * @summary Resolve Blueprint Id
     * @param {DefaultApiBlueprintResolveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintResolve(requestParameters: DefaultApiBlueprintResolveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blueprintResolve(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application - **recipe_package**: List with one or more paths to package(s) that contain recipe links. (Example: \'system/SIMOS/recipe_links\')
     * @summary Create Lookup
     * @param {DefaultApiCreateLookupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLookup(requestParameters: DefaultApiCreateLookupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLookup(requestParameters.application, requestParameters.recipePackage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get configuration of a single data source.
     * @summary Get
     * @param {DefaultApiDataSourceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGet(requestParameters: DefaultApiDataSourceGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceGet(requestParameters.dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all data sources found in DMSS (name and id for each data source).
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGetAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a data source configuration.
     * @summary Save
     * @param {DefaultApiDataSourceSaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceSave(requestParameters: DefaultApiDataSourceSaveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceSave(requestParameters.dataSourceId, requestParameters.dataSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a document to a package (or a data source) using an address.  - **address**:   - Reference to data source: PROTOCOL://DATA SOURCE   - Reference to package by id: PROTOCOL://DATA SOURCE/$ID   - Reference to package by path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE   The PROTOCOL is optional, and the default is dmss.  This endpoint can be used for: - Adding elements to a list attribute in an entity. - Adding a new document to a package / data source - Adding an object to an entity (for example filling in an optional, complex attribute)
     * @summary Add Document
     * @param {DefaultApiDocumentAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentAdd(requestParameters: DefaultApiDocumentAddRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentAdd(requestParameters.address, requestParameters.document, requestParameters.updateUncontained, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
     * @summary Add Raw
     * @param {DefaultApiDocumentAddSimpleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentAddSimple(requestParameters: DefaultApiDocumentAddSimpleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentAddSimple(requestParameters.dataSourceId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document as JSON string.  - **address**: An address to a package or a data source   - By id: PROTOCOL://DATA SOURCE/$ID.Attribute   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY.Attribute   - By query: PROTOCOL://DATA SOURCE/$ID.list(key=value)  The PROTOCOL is optional, and the default is dmss.  - **depth**: Maximum depth for resolving nested documents.
     * @summary Get
     * @param {DefaultApiDocumentGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentGet(requestParameters: DefaultApiDocumentGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentGet(requestParameters.address, requestParameters.depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a document from DMSS.
     * @summary Remove
     * @param {DefaultApiDocumentRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentRemove(requestParameters: DefaultApiDocumentRemoveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentRemove(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update document - **id_address**: <protocol>://<data_source>/$<document_uuid> (can also include an optional .<attribute> after <document_uuid>)
     * @summary Update
     * @param {DefaultApiDocumentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentUpdate(requestParameters: DefaultApiDocumentUpdateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentUpdate(requestParameters.idAddress, requestParameters.data, requestParameters.updateUncontained, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **address**:   - By path: PROTOCOL://DATA SOURCE/ROOT PACKAGE/SUB PACKAGE/ENTITY    The PROTOCOL is optional, and the default is dmss.
     * @summary Export Meta
     * @param {DefaultApiExportMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exportMeta(requestParameters: DefaultApiExportMetaRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).exportMeta(requestParameters.pathAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a new binary file and create a file entity with the binary data as content.  **file_id** The data source ID to be used for the file entity that will be created.
     * @summary Upload File
     * @param {DefaultApiFileUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileUpload(requestParameters: DefaultApiFileUploadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fileUpload(requestParameters.dataSourceId, requestParameters.data, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
     * @summary Get Acl
     * @param {DefaultApiGetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAcl(requestParameters: DefaultApiGetAclRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAcl(requestParameters.dataSourceId, requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck endpoint. Responds with \"OK\" - 200.
     * @summary Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiHealthcheckGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiHealthcheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a single lookup table.  - **application**: name of application
     * @summary Get Lookup
     * @param {DefaultApiGetLookupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLookup(requestParameters: DefaultApiGetLookupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLookup(requestParameters.application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a default entity of specified type. This entity is not stored in the database.  Rules for instantiation: - all required attributes, as defined in the blueprint, are included.   If the required attribute has a default value, that value will be used.   If not, an \'empty\' value will be used. For example empty string,   an empty list, the number 0, etc. - optional attributes are not included (also true if optional attribute has a default value)
     * @summary Instantiate
     * @param {DefaultApiInstantiateEntityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public instantiateEntity(requestParameters: DefaultApiInstantiateEntityRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).instantiateEntity(requestParameters.entity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get meta information from data source id.
     * @summary Get Meta By Id
     * @param {DefaultApiMetaByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public metaById(requestParameters: DefaultApiMetaByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).metaById(requestParameters.dataSourceId, requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
     * @summary Delete Reference
     * @param {DefaultApiReferenceDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public referenceDelete(requestParameters: DefaultApiReferenceDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).referenceDelete(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
     * @summary Search
     * @param {DefaultApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public search(requestParameters: DefaultApiSearchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).search(requestParameters.body, requestParameters.dataSources, requestParameters.sortByAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
     * @summary Set Acl
     * @param {DefaultApiSetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setAcl(requestParameters: DefaultApiSetAclRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setAcl(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.aCL, requestParameters.recursively, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
     * @summary New Personal Access Token
     * @param {DefaultApiTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenCreate(requestParameters: DefaultApiTokenCreateRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenCreate(requestParameters.scope, requestParameters.timeToLive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a personal access token (PAT).
     * @summary Revoke Personal Access Token
     * @param {DefaultApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenDelete(requestParameters: DefaultApiTokenDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenDelete(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all personal access tokens (PATs).
     * @summary List All Pats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenListAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenListAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an entity. Will return detailed error messages and status code 422 if the entity is invalid.  \"as_type\": Optional. Validate the root entity against this type instead of the one defined in the entity.
     * @summary Validate
     * @param {DefaultApiValidateEntityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validateEntity(requestParameters: DefaultApiValidateEntityRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validateEntity(requestParameters.entity, requestParameters.asType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an existing entity in dmss. Will return detailed error messages and status code 422 if an entity is invalid.
     * @summary Validate Existing
     * @param {DefaultApiValidateExistingEntityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validateExistingEntity(requestParameters: DefaultApiValidateExistingEntityRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validateExistingEntity(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
     * @summary Get Information On Authenticated User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public whoami(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}
