/* tslint:disable */
/* eslint-disable */
/**
 * Data Modelling Storage Service
 * API for basic data modelling interaction
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ACL } from '../models';
// @ts-ignore
import { AccessLevel } from '../models';
// @ts-ignore
import { BasicEntity } from '../models';
// @ts-ignore
import { DataSourceInformation } from '../models';
// @ts-ignore
import { DataSourceRequest } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { GetBlueprintResponse } from '../models';
// @ts-ignore
import { Lookup } from '../models';
// @ts-ignore
import { PATData } from '../models';
// @ts-ignore
import { Reference } from '../models';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **absolute_document_ref**: <data_source>/<path>/<document_name>
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (absoluteDocumentRef: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteDocumentRef' is not null or undefined
            assertParamExists('_export', 'absoluteDocumentRef', absoluteDocumentRef)
            const localVarPath = `/api/export/{absolute_document_ref}`
                .replace(`{${"absolute_document_ref"}}`, encodeURIComponent(String(absoluteDocumentRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById: async (dataSourceId: string, blobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobGetById', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobGetById', 'blobId', blobId)
            const localVarPath = `/api/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload: async (dataSourceId: string, blobId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('blobUpload', 'dataSourceId', dataSourceId)
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('blobUpload', 'blobId', blobId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('blobUpload', 'file', file)
            const localVarPath = `/api/blobs/{data_source_id}/{blob_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"blob_id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet: async (typeRef: string, context?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeRef' is not null or undefined
            assertParamExists('blueprintGet', 'typeRef', typeRef)
            const localVarPath = `/api/blueprint/{type_ref}`
                .replace(`{${"type_ref"}}`, encodeURIComponent(String(typeRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolve absolute_id of a blueprint to its type path.  - **absolute_id**: <data_source</<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve: async (absoluteId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteId' is not null or undefined
            assertParamExists('blueprintResolve', 'absoluteId', absoluteId)
            const localVarPath = `/api/resolve-path/{absolute_id}`
                .replace(`{${"absolute_id"}}`, encodeURIComponent(String(absoluteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application
         * @summary Create Lookup
         * @param {string} application 
         * @param {string} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLookup: async (application: string, recipePackage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            assertParamExists('createLookup', 'application', application)
            // verify required parameter 'recipePackage' is not null or undefined
            assertParamExists('createLookup', 'recipePackage', recipePackage)
            const localVarPath = `/api/application/{application}`
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (recipePackage !== undefined) {
                localVarQueryParameter['recipe_package'] = recipePackage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceGet', 'dataSourceId', dataSourceId)
            const localVarPath = `/api/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave: async (dataSourceId: string, dataSourceRequest: DataSourceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceId', dataSourceId)
            // verify required parameter 'dataSourceRequest' is not null or undefined
            assertParamExists('dataSourceSave', 'dataSourceRequest', dataSourceRequest)
            const localVarPath = `/api/data-sources/{data_source_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAdd: async (absoluteRef: string, body: object, updateUncontained?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteRef' is not null or undefined
            assertParamExists('documentAdd', 'absoluteRef', absoluteRef)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('documentAdd', 'body', body)
            const localVarPath = `/api/documents/{absolute_ref}`
                .replace(`{${"absolute_ref"}}`, encodeURIComponent(String(absoluteRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddSimple: async (dataSourceId: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentAddSimple', 'dataSourceId', dataSourceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('documentAddSimple', 'body', body)
            const localVarPath = `/api/documents/{data_source_id}/add-raw`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.  - **path_reference**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Add To Path
         * @param {string} pathReference 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddToPath: async (pathReference: string, document: string, updateUncontained?: boolean, files?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathReference' is not null or undefined
            assertParamExists('documentAddToPath', 'pathReference', pathReference)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('documentAddToPath', 'document', document)
            const localVarPath = `/api/documents/{path_reference}/add-to-path`
                .replace(`{${"path_reference"}}`, encodeURIComponent(String(pathReference)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document as JSON string.  - **id_reference**: <data_source>/<document_uuid> - **depth**: Maximum depth for resolving nested documents.
         * @summary Get By Id
         * @param {string} idReference 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetById: async (idReference: string, depth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idReference' is not null or undefined
            assertParamExists('documentGetById', 'idReference', idReference)
            const localVarPath = `/api/documents/{id_reference}`
                .replace(`{${"id_reference"}}`, encodeURIComponent(String(idReference)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a document by its absolute path.  - **absolute_path**: <protocol>://<data_source>/<path>.<attribute>
         * @summary Get By Path
         * @param {string} absolutePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetByPath: async (absolutePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absolutePath' is not null or undefined
            assertParamExists('documentGetByPath', 'absolutePath', absolutePath)
            const localVarPath = `/api/documents-by-path/{absolute_path}`
                .replace(`{${"absolute_path"}}`, encodeURIComponent(String(absolutePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove document  - **dotted_id**: can have value <document_id> or <document_id>.<attribute_path>  Example: dotted_id=3978d9ca-2d7a-4b47-8fed-57710f6cf50b.attributes.1 will remove the first element in the attribute list of a blueprint with the given id.
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemove: async (dataSourceId: string, dottedId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentRemove', 'dataSourceId', dataSourceId)
            // verify required parameter 'dottedId' is not null or undefined
            assertParamExists('documentRemove', 'dottedId', dottedId)
            const localVarPath = `/api/documents/{data_source_id}/{dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"dotted_id"}}`, encodeURIComponent(String(dottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a document from DMSS.  - **directory**: path to document to remove.
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemoveByPath: async (dataSourceId: string, directory: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentRemoveByPath', 'dataSourceId', dataSourceId)
            // verify required parameter 'directory' is not null or undefined
            assertParamExists('documentRemoveByPath', 'directory', directory)
            const localVarPath = `/api/documents/{data_source_id}/remove-by-path/{directory}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"directory"}}`, encodeURIComponent(String(directory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update document
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate: async (dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('documentUpdate', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentUpdate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentUpdate', 'data', data)
            const localVarPath = `/api/documents/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (updateUncontained !== undefined) {
                localVarQueryParameter['update_uncontained'] = updateUncontained;
            }


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
            if (attribute !== undefined) { 
                localVarFormParams.append('attribute', attribute as any);
            }
                if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **absolute_document_ref**: <data_source>/<path_to_entity>/<entity_name>
         * @summary Export Meta
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMeta: async (absoluteDocumentRef: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'absoluteDocumentRef' is not null or undefined
            assertParamExists('exportMeta', 'absoluteDocumentRef', absoluteDocumentRef)
            const localVarPath = `/api/export/meta/{absolute_document_ref}`
                .replace(`{${"absolute_document_ref"}}`, encodeURIComponent(String(absoluteDocumentRef)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl: async (dataSourceId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('getAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getAcl', 'documentId', documentId)
            const localVarPath = `/api/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiHealthcheckGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLookup: async (application: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getLookup', 'application', application)
            const localVarPath = `/api/application/{application}`
                .replace(`{${"application"}}`, encodeURIComponent(String(application)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new entity and return it.  (entity is not saved in DMSS)
         * @summary Instantiate
         * @param {BasicEntity} basicEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instantiateEntity: async (basicEntity: BasicEntity, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basicEntity' is not null or undefined
            assertParamExists('instantiateEntity', 'basicEntity', basicEntity)
            const localVarPath = `/api/entity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(basicEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete: async (dataSourceId: string, documentDottedId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('referenceDelete', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentDottedId' is not null or undefined
            assertParamExists('referenceDelete', 'documentDottedId', documentDottedId)
            const localVarPath = `/api/reference/{data_source_id}/{document_dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(documentDottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add reference to an entity.  Used to add uncontained attributes to an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute> - **reference**: a reference object in JSON format
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceInsert: async (dataSourceId: string, documentDottedId: string, reference: Reference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('referenceInsert', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentDottedId' is not null or undefined
            assertParamExists('referenceInsert', 'documentDottedId', documentDottedId)
            // verify required parameter 'reference' is not null or undefined
            assertParamExists('referenceInsert', 'reference', reference)
            const localVarPath = `/api/reference/{data_source_id}/{document_dotted_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_dotted_id"}}`, encodeURIComponent(String(documentDottedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (body: object, dataSources?: Array<string>, sortByAttribute?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('search', 'body', body)
            const localVarPath = `/api/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (dataSources) {
                localVarQueryParameter['data_sources'] = dataSources;
            }

            if (sortByAttribute !== undefined) {
                localVarQueryParameter['sort_by_attribute'] = sortByAttribute;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl: async (dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists('setAcl', 'dataSourceId', dataSourceId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('setAcl', 'documentId', documentId)
            // verify required parameter 'aCL' is not null or undefined
            assertParamExists('setAcl', 'aCL', aCL)
            const localVarPath = `/api/acl/{data_source_id}/{document_id}`
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (recursively !== undefined) {
                localVarQueryParameter['recursively'] = recursively;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aCL, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (scope?: AccessLevel, timeToLive?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (timeToLive !== undefined) {
                localVarQueryParameter['time_to_live'] = timeToLive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokenDelete', 'tokenId', tokenId)
            const localVarPath = `/api/token/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Access-Key", configuration)

            // authentication OAuth2AuthorizationCodeBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2AuthorizationCodeBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **absolute_document_ref**: <data_source>/<path>/<document_name>
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(absoluteDocumentRef: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(absoluteDocumentRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobGetById(dataSourceId: string, blobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobGetById(dataSourceId, blobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blobUpload(dataSourceId: string, blobId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blobUpload(dataSourceId, blobId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintGet(typeRef: string, context?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlueprintResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintGet(typeRef, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resolve absolute_id of a blueprint to its type path.  - **absolute_id**: <data_source</<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blueprintResolve(absoluteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blueprintResolve(absoluteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application
         * @summary Create Lookup
         * @param {string} application 
         * @param {string} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLookup(application: string, recipePackage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLookup(application, recipePackage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGet(dataSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGet(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSourceInformation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSourceSave(dataSourceId, dataSourceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAdd(absoluteRef: string, body: object, updateUncontained?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAdd(absoluteRef, body, updateUncontained, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAddSimple(dataSourceId: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAddSimple(dataSourceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.  - **path_reference**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Add To Path
         * @param {string} pathReference 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentAddToPath(pathReference: string, document: string, updateUncontained?: boolean, files?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentAddToPath(pathReference, document, updateUncontained, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get document as JSON string.  - **id_reference**: <data_source>/<document_uuid> - **depth**: Maximum depth for resolving nested documents.
         * @summary Get By Id
         * @param {string} idReference 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentGetById(idReference: string, depth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentGetById(idReference, depth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a document by its absolute path.  - **absolute_path**: <protocol>://<data_source>/<path>.<attribute>
         * @summary Get By Path
         * @param {string} absolutePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentGetByPath(absolutePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentGetByPath(absolutePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove document  - **dotted_id**: can have value <document_id> or <document_id>.<attribute_path>  Example: dotted_id=3978d9ca-2d7a-4b47-8fed-57710f6cf50b.attributes.1 will remove the first element in the attribute list of a blueprint with the given id.
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentRemove(dataSourceId: string, dottedId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentRemove(dataSourceId, dottedId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a document from DMSS.  - **directory**: path to document to remove.
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentRemoveByPath(dataSourceId: string, directory: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentRemoveByPath(dataSourceId, directory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update document
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentUpdate(dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentUpdate(dataSourceId, documentId, data, updateUncontained, attribute, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **absolute_document_ref**: <data_source>/<path_to_entity>/<entity_name>
         * @summary Export Meta
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportMeta(absoluteDocumentRef: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportMeta(absoluteDocumentRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcl(dataSourceId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcl(dataSourceId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiHealthcheckGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiHealthcheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLookup(application: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLookup(application, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new entity and return it.  (entity is not saved in DMSS)
         * @summary Instantiate
         * @param {BasicEntity} basicEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instantiateEntity(basicEntity: BasicEntity, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instantiateEntity(basicEntity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referenceDelete(dataSourceId: string, documentDottedId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referenceDelete(dataSourceId, documentDottedId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add reference to an entity.  Used to add uncontained attributes to an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute> - **reference**: a reference object in JSON format
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referenceInsert(dataSourceId: string, documentDottedId: string, reference: Reference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referenceInsert(dataSourceId, documentDottedId, reference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(body, dataSources, sortByAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAcl(dataSourceId, documentId, aCL, recursively, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(scope, timeToLive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenListAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PATData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenListAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Download a zip-folder with one or more documents as json file(s).  - **absolute_document_ref**: <data_source>/<path>/<document_name>
         * @summary Export
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(absoluteDocumentRef: string, options?: any): AxiosPromise<void> {
            return localVarFp._export(absoluteDocumentRef, options).then((request) => request(axios, basePath));
        },
        /**
         * Get blob from id. A blob (binary large object) can be anything from video to text file.
         * @summary Get By Id
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobGetById(dataSourceId: string, blobId: string, options?: any): AxiosPromise<File> {
            return localVarFp.blobGetById(dataSourceId, blobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new blob. A blob (binary large object) can be anything from video to text file.
         * @summary Upload
         * @param {string} dataSourceId 
         * @param {string} blobId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blobUpload(dataSourceId: string, blobId: string, file: File, options?: any): AxiosPromise<string> {
            return localVarFp.blobUpload(dataSourceId, blobId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
         * @summary Get Blueprint
         * @param {string} typeRef 
         * @param {string} [context] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintGet(typeRef: string, context?: string, options?: any): AxiosPromise<GetBlueprintResponse> {
            return localVarFp.blueprintGet(typeRef, context, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolve absolute_id of a blueprint to its type path.  - **absolute_id**: <data_source</<blueprint_uuid>
         * @summary Resolve Blueprint Id
         * @param {string} absoluteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blueprintResolve(absoluteId: string, options?: any): AxiosPromise<string> {
            return localVarFp.blueprintResolve(absoluteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application
         * @summary Create Lookup
         * @param {string} application 
         * @param {string} recipePackage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLookup(application: string, recipePackage: string, options?: any): AxiosPromise<void> {
            return localVarFp.createLookup(application, recipePackage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get configuration of a single data source.
         * @summary Get
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGet(dataSourceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.dataSourceGet(dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all data sources found in DMSS (name and id for each data source).
         * @summary Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceGetAll(options?: any): AxiosPromise<Array<DataSourceInformation>> {
            return localVarFp.dataSourceGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a data source configuration.
         * @summary Save
         * @param {string} dataSourceId 
         * @param {DataSourceRequest} dataSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSourceSave(dataSourceId: string, dataSourceRequest: DataSourceRequest, options?: any): AxiosPromise<string> {
            return localVarFp.dataSourceSave(dataSourceId, dataSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
         * @summary Add By Parent Id
         * @param {string} absoluteRef 
         * @param {object} body 
         * @param {boolean} [updateUncontained] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAdd(absoluteRef: string, body: object, updateUncontained?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.documentAdd(absoluteRef, body, updateUncontained, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
         * @summary Add Raw
         * @param {string} dataSourceId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddSimple(dataSourceId: string, body: object, options?: any): AxiosPromise<string> {
            return localVarFp.documentAddSimple(dataSourceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.  - **path_reference**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Add To Path
         * @param {string} pathReference 
         * @param {string} document 
         * @param {boolean} [updateUncontained] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentAddToPath(pathReference: string, document: string, updateUncontained?: boolean, files?: Array<File>, options?: any): AxiosPromise<object> {
            return localVarFp.documentAddToPath(pathReference, document, updateUncontained, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document as JSON string.  - **id_reference**: <data_source>/<document_uuid> - **depth**: Maximum depth for resolving nested documents.
         * @summary Get By Id
         * @param {string} idReference 
         * @param {number} [depth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetById(idReference: string, depth?: number, options?: any): AxiosPromise<object> {
            return localVarFp.documentGetById(idReference, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a document by its absolute path.  - **absolute_path**: <protocol>://<data_source>/<path>.<attribute>
         * @summary Get By Path
         * @param {string} absolutePath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentGetByPath(absolutePath: string, options?: any): AxiosPromise<object> {
            return localVarFp.documentGetByPath(absolutePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove document  - **dotted_id**: can have value <document_id> or <document_id>.<attribute_path>  Example: dotted_id=3978d9ca-2d7a-4b47-8fed-57710f6cf50b.attributes.1 will remove the first element in the attribute list of a blueprint with the given id.
         * @summary Remove
         * @param {string} dataSourceId 
         * @param {string} dottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemove(dataSourceId: string, dottedId: string, options?: any): AxiosPromise<string> {
            return localVarFp.documentRemove(dataSourceId, dottedId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a document from DMSS.  - **directory**: path to document to remove.
         * @summary Remove By Path
         * @param {string} dataSourceId 
         * @param {string} directory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentRemoveByPath(dataSourceId: string, directory: string, options?: any): AxiosPromise<any> {
            return localVarFp.documentRemoveByPath(dataSourceId, directory, options).then((request) => request(axios, basePath));
        },
        /**
         * Update document
         * @summary Update
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {string} data 
         * @param {boolean} [updateUncontained] 
         * @param {string} [attribute] 
         * @param {Array<File>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentUpdate(dataSourceId: string, documentId: string, data: string, updateUncontained?: boolean, attribute?: string, files?: Array<File>, options?: any): AxiosPromise<any> {
            return localVarFp.documentUpdate(dataSourceId, documentId, data, updateUncontained, attribute, files, options).then((request) => request(axios, basePath));
        },
        /**
         * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **absolute_document_ref**: <data_source>/<path_to_entity>/<entity_name>
         * @summary Export Meta
         * @param {string} absoluteDocumentRef 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMeta(absoluteDocumentRef: string, options?: any): AxiosPromise<any> {
            return localVarFp.exportMeta(absoluteDocumentRef, options).then((request) => request(axios, basePath));
        },
        /**
         * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Get Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcl(dataSourceId: string, documentId: string, options?: any): AxiosPromise<ACL> {
            return localVarFp.getAcl(dataSourceId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck endpoint. Responds with \"OK\" - 200.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiHealthcheckGet(options?: any): AxiosPromise<string> {
            return localVarFp.getApiHealthcheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single lookup table.  - **application**: name of application
         * @summary Get Lookup
         * @param {string} application 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLookup(application: string, options?: any): AxiosPromise<Lookup> {
            return localVarFp.getLookup(application, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new entity and return it.  (entity is not saved in DMSS)
         * @summary Instantiate
         * @param {BasicEntity} basicEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instantiateEntity(basicEntity: BasicEntity, options?: any): AxiosPromise<object> {
            return localVarFp.instantiateEntity(basicEntity, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
         * @summary Delete Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDelete(dataSourceId: string, documentDottedId: string, options?: any): AxiosPromise<object> {
            return localVarFp.referenceDelete(dataSourceId, documentDottedId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add reference to an entity.  Used to add uncontained attributes to an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute> - **reference**: a reference object in JSON format
         * @summary Insert Reference
         * @param {string} dataSourceId 
         * @param {string} documentDottedId 
         * @param {Reference} reference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceInsert(dataSourceId: string, documentDottedId: string, reference: Reference, options?: any): AxiosPromise<object> {
            return localVarFp.referenceInsert(dataSourceId, documentDottedId, reference, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
         * @summary Search
         * @param {object} body 
         * @param {Array<string>} [dataSources] 
         * @param {string} [sortByAttribute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: object, dataSources?: Array<string>, sortByAttribute?: string, options?: any): AxiosPromise<object> {
            return localVarFp.search(body, dataSources, sortByAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
         * @summary Set Acl
         * @param {string} dataSourceId 
         * @param {string} documentId 
         * @param {ACL} aCL 
         * @param {boolean} [recursively] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAcl(dataSourceId: string, documentId: string, aCL: ACL, recursively?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.setAcl(dataSourceId, documentId, aCL, recursively, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
         * @summary New Personal Access Token
         * @param {AccessLevel} [scope] 
         * @param {number} [timeToLive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(scope?: AccessLevel, timeToLive?: number, options?: any): AxiosPromise<string> {
            return localVarFp.tokenCreate(scope, timeToLive, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a personal access token (PAT).
         * @summary Revoke Personal Access Token
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(tokenId: string, options?: any): AxiosPromise<string> {
            return localVarFp.tokenDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all personal access tokens (PATs).
         * @summary List All Pats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenListAll(options?: any): AxiosPromise<Array<PATData>> {
            return localVarFp.tokenListAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
         * @summary Get Information On Authenticated User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): AxiosPromise<any> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _export operation in DefaultApi.
 * @export
 * @interface DefaultApiExportRequest
 */
export interface DefaultApiExportRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExport
     */
    readonly absoluteDocumentRef: string
}

/**
 * Request parameters for blobGetById operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobGetByIdRequest
 */
export interface DefaultApiBlobGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobGetById
     */
    readonly blobId: string
}

/**
 * Request parameters for blobUpload operation in DefaultApi.
 * @export
 * @interface DefaultApiBlobUploadRequest
 */
export interface DefaultApiBlobUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlobUpload
     */
    readonly blobId: string

    /**
     * 
     * @type {File}
     * @memberof DefaultApiBlobUpload
     */
    readonly file: File
}

/**
 * Request parameters for blueprintGet operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintGetRequest
 */
export interface DefaultApiBlueprintGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintGet
     */
    readonly typeRef: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintGet
     */
    readonly context?: string
}

/**
 * Request parameters for blueprintResolve operation in DefaultApi.
 * @export
 * @interface DefaultApiBlueprintResolveRequest
 */
export interface DefaultApiBlueprintResolveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBlueprintResolve
     */
    readonly absoluteId: string
}

/**
 * Request parameters for createLookup operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateLookupRequest
 */
export interface DefaultApiCreateLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateLookup
     */
    readonly application: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateLookup
     */
    readonly recipePackage: string
}

/**
 * Request parameters for dataSourceGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceGetRequest
 */
export interface DefaultApiDataSourceGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceGet
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for dataSourceSave operation in DefaultApi.
 * @export
 * @interface DefaultApiDataSourceSaveRequest
 */
export interface DefaultApiDataSourceSaveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {DataSourceRequest}
     * @memberof DefaultApiDataSourceSave
     */
    readonly dataSourceRequest: DataSourceRequest
}

/**
 * Request parameters for documentAdd operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentAddRequest
 */
export interface DefaultApiDocumentAddRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAdd
     */
    readonly absoluteRef: string

    /**
     * 
     * @type {object}
     * @memberof DefaultApiDocumentAdd
     */
    readonly body: object

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentAdd
     */
    readonly updateUncontained?: boolean
}

/**
 * Request parameters for documentAddSimple operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentAddSimpleRequest
 */
export interface DefaultApiDocumentAddSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAddSimple
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {object}
     * @memberof DefaultApiDocumentAddSimple
     */
    readonly body: object
}

/**
 * Request parameters for documentAddToPath operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentAddToPathRequest
 */
export interface DefaultApiDocumentAddToPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAddToPath
     */
    readonly pathReference: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentAddToPath
     */
    readonly document: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentAddToPath
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {Array<File>}
     * @memberof DefaultApiDocumentAddToPath
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for documentGetById operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentGetByIdRequest
 */
export interface DefaultApiDocumentGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetById
     */
    readonly idReference: string

    /**
     * 
     * @type {number}
     * @memberof DefaultApiDocumentGetById
     */
    readonly depth?: number
}

/**
 * Request parameters for documentGetByPath operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentGetByPathRequest
 */
export interface DefaultApiDocumentGetByPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentGetByPath
     */
    readonly absolutePath: string
}

/**
 * Request parameters for documentRemove operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentRemoveRequest
 */
export interface DefaultApiDocumentRemoveRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentRemove
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentRemove
     */
    readonly dottedId: string
}

/**
 * Request parameters for documentRemoveByPath operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentRemoveByPathRequest
 */
export interface DefaultApiDocumentRemoveByPathRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentRemoveByPath
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentRemoveByPath
     */
    readonly directory: string
}

/**
 * Request parameters for documentUpdate operation in DefaultApi.
 * @export
 * @interface DefaultApiDocumentUpdateRequest
 */
export interface DefaultApiDocumentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly data: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly updateUncontained?: boolean

    /**
     * 
     * @type {string}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly attribute?: string

    /**
     * 
     * @type {Array<File>}
     * @memberof DefaultApiDocumentUpdate
     */
    readonly files?: Array<File>
}

/**
 * Request parameters for exportMeta operation in DefaultApi.
 * @export
 * @interface DefaultApiExportMetaRequest
 */
export interface DefaultApiExportMetaRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiExportMeta
     */
    readonly absoluteDocumentRef: string
}

/**
 * Request parameters for getAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiGetAclRequest
 */
export interface DefaultApiGetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetAcl
     */
    readonly documentId: string
}

/**
 * Request parameters for getLookup operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLookupRequest
 */
export interface DefaultApiGetLookupRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetLookup
     */
    readonly application: string
}

/**
 * Request parameters for instantiateEntity operation in DefaultApi.
 * @export
 * @interface DefaultApiInstantiateEntityRequest
 */
export interface DefaultApiInstantiateEntityRequest {
    /**
     * 
     * @type {BasicEntity}
     * @memberof DefaultApiInstantiateEntity
     */
    readonly basicEntity: BasicEntity
}

/**
 * Request parameters for referenceDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiReferenceDeleteRequest
 */
export interface DefaultApiReferenceDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceDelete
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceDelete
     */
    readonly documentDottedId: string
}

/**
 * Request parameters for referenceInsert operation in DefaultApi.
 * @export
 * @interface DefaultApiReferenceInsertRequest
 */
export interface DefaultApiReferenceInsertRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceInsert
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiReferenceInsert
     */
    readonly documentDottedId: string

    /**
     * 
     * @type {Reference}
     * @memberof DefaultApiReferenceInsert
     */
    readonly reference: Reference
}

/**
 * Request parameters for search operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchRequest
 */
export interface DefaultApiSearchRequest {
    /**
     * 
     * @type {object}
     * @memberof DefaultApiSearch
     */
    readonly body: object

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiSearch
     */
    readonly dataSources?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSearch
     */
    readonly sortByAttribute?: string
}

/**
 * Request parameters for setAcl operation in DefaultApi.
 * @export
 * @interface DefaultApiSetAclRequest
 */
export interface DefaultApiSetAclRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSetAcl
     */
    readonly documentId: string

    /**
     * 
     * @type {ACL}
     * @memberof DefaultApiSetAcl
     */
    readonly aCL: ACL

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiSetAcl
     */
    readonly recursively?: boolean
}

/**
 * Request parameters for tokenCreate operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenCreateRequest
 */
export interface DefaultApiTokenCreateRequest {
    /**
     * 
     * @type {AccessLevel}
     * @memberof DefaultApiTokenCreate
     */
    readonly scope?: AccessLevel

    /**
     * 
     * @type {number}
     * @memberof DefaultApiTokenCreate
     */
    readonly timeToLive?: number
}

/**
 * Request parameters for tokenDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiTokenDeleteRequest
 */
export interface DefaultApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiTokenDelete
     */
    readonly tokenId: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Download a zip-folder with one or more documents as json file(s).  - **absolute_document_ref**: <data_source>/<path>/<document_name>
     * @summary Export
     * @param {DefaultApiExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _export(requestParameters: DefaultApiExportRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration)._export(requestParameters.absoluteDocumentRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get blob from id. A blob (binary large object) can be anything from video to text file.
     * @summary Get By Id
     * @param {DefaultApiBlobGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobGetById(requestParameters: DefaultApiBlobGetByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blobGetById(requestParameters.dataSourceId, requestParameters.blobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a new blob. A blob (binary large object) can be anything from video to text file.
     * @summary Upload
     * @param {DefaultApiBlobUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blobUpload(requestParameters: DefaultApiBlobUploadRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blobUpload(requestParameters.dataSourceId, requestParameters.blobId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the Blueprint and Recipes from a type reference (including inherited attributes).  - **type_ref**: <protocol>://<data_source>/<path_to_blueprint> - **context**: name of application that has Ui-/StorageRecipe lookup table (optional attribute)
     * @summary Get Blueprint
     * @param {DefaultApiBlueprintGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintGet(requestParameters: DefaultApiBlueprintGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blueprintGet(requestParameters.typeRef, requestParameters.context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolve absolute_id of a blueprint to its type path.  - **absolute_id**: <data_source</<blueprint_uuid>
     * @summary Resolve Blueprint Id
     * @param {DefaultApiBlueprintResolveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blueprintResolve(requestParameters: DefaultApiBlueprintResolveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).blueprintResolve(requestParameters.absoluteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a recipe lookup table from a package containing RecipeLinks. Associate it with an application. This can be used for setting Ui- and StorageRecipes for specific applications.  - **application**: name of application
     * @summary Create Lookup
     * @param {DefaultApiCreateLookupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLookup(requestParameters: DefaultApiCreateLookupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLookup(requestParameters.application, requestParameters.recipePackage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get configuration of a single data source.
     * @summary Get
     * @param {DefaultApiDataSourceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGet(requestParameters: DefaultApiDataSourceGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceGet(requestParameters.dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all data sources found in DMSS (name and id for each data source).
     * @summary Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceGetAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a data source configuration.
     * @summary Save
     * @param {DefaultApiDataSourceSaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataSourceSave(requestParameters: DefaultApiDataSourceSaveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).dataSourceSave(requestParameters.dataSourceId, requestParameters.dataSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document to absolute ref (root of data source, or another document). If added to another document, a valid attribute type check is done. Select parent with format \'data_source/document_id.attribute.index.attribute\'
     * @summary Add By Parent Id
     * @param {DefaultApiDocumentAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentAdd(requestParameters: DefaultApiDocumentAddRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentAdd(requestParameters.absoluteRef, requestParameters.body, requestParameters.updateUncontained, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the document \'as-is\' to the datasource. NOTE: The \'explorer-add\' operation is to be preferred. This is mainly for bootstrapping and imports. Blueprint need not exist, and so there is no validation or splitting of entities. Posted document must be a valid Entity.
     * @summary Add Raw
     * @param {DefaultApiDocumentAddSimpleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentAddSimple(requestParameters: DefaultApiDocumentAddSimpleRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentAddSimple(requestParameters.dataSourceId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as \'add_to_parent\', but reference parent by path instead of ID. Also supports files.  - **path_reference**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
     * @summary Add To Path
     * @param {DefaultApiDocumentAddToPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentAddToPath(requestParameters: DefaultApiDocumentAddToPathRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentAddToPath(requestParameters.pathReference, requestParameters.document, requestParameters.updateUncontained, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document as JSON string.  - **id_reference**: <data_source>/<document_uuid> - **depth**: Maximum depth for resolving nested documents.
     * @summary Get By Id
     * @param {DefaultApiDocumentGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentGetById(requestParameters: DefaultApiDocumentGetByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentGetById(requestParameters.idReference, requestParameters.depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a document by its absolute path.  - **absolute_path**: <protocol>://<data_source>/<path>.<attribute>
     * @summary Get By Path
     * @param {DefaultApiDocumentGetByPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentGetByPath(requestParameters: DefaultApiDocumentGetByPathRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentGetByPath(requestParameters.absolutePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove document  - **dotted_id**: can have value <document_id> or <document_id>.<attribute_path>  Example: dotted_id=3978d9ca-2d7a-4b47-8fed-57710f6cf50b.attributes.1 will remove the first element in the attribute list of a blueprint with the given id.
     * @summary Remove
     * @param {DefaultApiDocumentRemoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentRemove(requestParameters: DefaultApiDocumentRemoveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentRemove(requestParameters.dataSourceId, requestParameters.dottedId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a document from DMSS.  - **directory**: path to document to remove.
     * @summary Remove By Path
     * @param {DefaultApiDocumentRemoveByPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentRemoveByPath(requestParameters: DefaultApiDocumentRemoveByPathRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentRemoveByPath(requestParameters.dataSourceId, requestParameters.directory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update document
     * @summary Update
     * @param {DefaultApiDocumentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public documentUpdate(requestParameters: DefaultApiDocumentUpdateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).documentUpdate(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.data, requestParameters.updateUncontained, requestParameters.attribute, requestParameters.files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export only the metadata of an entity. An entities metadata is concatenated from the \"top down\". Inheriting parents meta, and overriding for any specified further down.  If no metadata is defined anywhere in the tree, an empty object is returned.  - **absolute_document_ref**: <data_source>/<path_to_entity>/<entity_name>
     * @summary Export Meta
     * @param {DefaultApiExportMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exportMeta(requestParameters: DefaultApiExportMetaRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).exportMeta(requestParameters.absoluteDocumentRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
     * @summary Get Acl
     * @param {DefaultApiGetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAcl(requestParameters: DefaultApiGetAclRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAcl(requestParameters.dataSourceId, requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck endpoint. Responds with \"OK\" - 200.
     * @summary Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiHealthcheckGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getApiHealthcheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a single lookup table.  - **application**: name of application
     * @summary Get Lookup
     * @param {DefaultApiGetLookupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLookup(requestParameters: DefaultApiGetLookupRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLookup(requestParameters.application, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new entity and return it.  (entity is not saved in DMSS)
     * @summary Instantiate
     * @param {DefaultApiInstantiateEntityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public instantiateEntity(requestParameters: DefaultApiInstantiateEntityRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).instantiateEntity(requestParameters.basicEntity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a reference in an entity.  Used to delete uncontained attributes in an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute>
     * @summary Delete Reference
     * @param {DefaultApiReferenceDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public referenceDelete(requestParameters: DefaultApiReferenceDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).referenceDelete(requestParameters.dataSourceId, requestParameters.documentDottedId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add reference to an entity.  Used to add uncontained attributes to an entity.  - **document_dotted_id**: <data_source>/<path_to_entity>/<entity_name>.<attribute> - **reference**: a reference object in JSON format
     * @summary Insert Reference
     * @param {DefaultApiReferenceInsertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public referenceInsert(requestParameters: DefaultApiReferenceInsertRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).referenceInsert(requestParameters.dataSourceId, requestParameters.documentDottedId, requestParameters.reference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a list of data source id\'s as a query parameter, and search those data sources for the posted dictionary. If data source list is empty, search all databases.  - **data**: a JSON document, must include a \"type\" attribute. Can also include other attributes like \"name\". - **data_sources**: List of data sources to search in. - **sort_by_attribute**: which attribute to sort the result by
     * @summary Search
     * @param {DefaultApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public search(requestParameters: DefaultApiSearchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).search(requestParameters.body, requestParameters.dataSources, requestParameters.sortByAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update access control list (ACL) for a document.  The ACL determines which access a given user has for a document (Read, Write or None).
     * @summary Set Acl
     * @param {DefaultApiSetAclRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setAcl(requestParameters: DefaultApiSetAclRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setAcl(requestParameters.dataSourceId, requestParameters.documentId, requestParameters.aCL, requestParameters.recursively, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a personal access token (PAT).  - **scope**: WRITE, READ or NONE - **time_to_live**: Optional parameter to set time to life in seconds (default is 30 days)
     * @summary New Personal Access Token
     * @param {DefaultApiTokenCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenCreate(requestParameters: DefaultApiTokenCreateRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenCreate(requestParameters.scope, requestParameters.timeToLive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a personal access token (PAT).
     * @summary Revoke Personal Access Token
     * @param {DefaultApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenDelete(requestParameters: DefaultApiTokenDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenDelete(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all personal access tokens (PATs).
     * @summary List All Pats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenListAll(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenListAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about the user sending the request.  If no user is authenticated, a default \"nologin\" user is returned.
     * @summary Get Information On Authenticated User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public whoami(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}
